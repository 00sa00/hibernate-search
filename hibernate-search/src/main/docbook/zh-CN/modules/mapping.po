# Chinese translations for PACKAGE package.
# Automatically generated, 2009.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2009-05-26 16:41+0000\n"
"PO-Revision-Date: 2009-05-26 15:46+0000\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: mapping.xml:30
#, no-c-format
msgid "Mapping entities to the index structure"
msgstr ""

#. Tag: para
#: mapping.xml:32
#, no-c-format
msgid ""
"All the metadata information needed to index entities is described through "
"annotations. There is no need for xml mapping files. In fact there is "
"currently no xml configuration option available (see <ulink url=\"http://"
"opensource.atlassian.com/projects/hibernate/browse/HSEARCH-210\">HSEARCH-"
"210</ulink>). You can still use hibernate mapping files for the basic "
"Hibernate configuration, but the Search specific configuration has to be "
"expressed via annotations."
msgstr ""

#. Tag: title
#: mapping.xml:41
#, no-c-format
msgid "Mapping an entity"
msgstr ""

#. Tag: title
#: mapping.xml:44
#, no-c-format
msgid "Basic mapping"
msgstr ""

#. Tag: para
#: mapping.xml:46
#, no-c-format
msgid ""
"First, we must declare a persistent class as indexable. This is done by "
"annotating the class with <literal>@Indexed</literal> (all entities not "
"annotated with <literal>@Indexed</literal> will be ignored by the indexing "
"process):"
msgstr ""

#. Tag: title
#: mapping.xml:52
#, no-c-format
msgid ""
"Making a class indexable using the <classname>@Indexed</classname> annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:55
#, no-c-format
msgid ""
"@Entity\n"
"<emphasis role=\"bold\">@Indexed(index=\"indexes/essays\")</emphasis>\n"
"public class Essay {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:58
#, no-c-format
msgid ""
"The <literal>index</literal> attribute tells Hibernate what the Lucene "
"directory name is (usually a directory on your file system). It is "
"recommended to define a base directory for all Lucene indexes using the "
"<literal>hibernate.search.default.indexBase</literal> property in your "
"configuration file. Alternatively you can specify a base directory per "
"indexed entity by specifying <literal>hibernate.search.&lt;index&gt;."
"indexBase, </literal>where <literal>&lt;index&gt;</literal> is the fully "
"qualified classname of the indexed entity. Each entity instance will be "
"represented by a Lucene <classname>Document</classname> inside the given "
"index (aka Directory)."
msgstr ""

#. Tag: para
#: mapping.xml:70
#, no-c-format
msgid ""
"For each property (or attribute) of your entity, you have the ability to "
"describe how it will be indexed. The default (no annotation present) means "
"that the property is completely ignored by the indexing process. "
"<literal>@Field</literal> does declare a property as indexed. When indexing "
"an element to a Lucene document you can specify how it is indexed:"
msgstr ""

#. Tag: para
#: mapping.xml:79
#, no-c-format
msgid ""
"<literal>name</literal> : describe under which name, the property should be "
"stored in the Lucene Document. The default value is the property name "
"(following the JavaBeans convention)"
msgstr ""

#. Tag: para
#: mapping.xml:85
#, no-c-format
msgid ""
"<literal>store</literal> : describe whether or not the property is stored in "
"the Lucene index. You can store the value <literal>Store.YES</literal> "
"(consuming more space in the index but allowing projection, see <xref "
"linkend=\"projections\"/> for more information), store it in a compressed "
"way <literal>Store.COMPRESS</literal> (this does consume more CPU), or avoid "
"any storage <literal>Store.NO</literal> (this is the default value). When a "
"property is stored, you can retrieve its original value from the Lucene "
"Document. This is not related to whether the element is indexed or not."
msgstr ""

#. Tag: para
#: mapping.xml:98
#, no-c-format
msgid ""
"index: describe how the element is indexed and the type of information "
"store. The different values are <literal>Index.NO</literal> (no indexing, ie "
"cannot be found by a query), <literal>Index.TOKENIZED</literal> (use an "
"analyzer to process the property), <literal>Index.UN_TOKENIZED</literal> (no "
"analyzer pre-processing), <literal>Index.NO_NORMS</literal> (do not store "
"the normalization data). The default value is <literal>TOKENIZED</literal>."
msgstr ""

#. Tag: para
#: mapping.xml:109
#, no-c-format
msgid ""
"termVector: describes collections of term-frequency pairs. This attribute "
"enables term vectors being stored during indexing so they are available "
"within documents. The default value is TermVector.NO."
msgstr ""

#. Tag: para
#: mapping.xml:114
#, no-c-format
msgid "The different values of this attribute are:"
msgstr ""

#. Tag: entry
#: mapping.xml:120
#, no-c-format
msgid "Value"
msgstr ""

#. Tag: entry
#: mapping.xml:122
#, no-c-format
msgid "Definition"
msgstr ""

#. Tag: entry
#: mapping.xml:128
#, no-c-format
msgid "TermVector.YES"
msgstr ""

#. Tag: entry
#: mapping.xml:130
#, no-c-format
msgid ""
"Store the term vectors of each document. This produces two synchronized "
"arrays, one contains document terms and the other contains the term's "
"frequency."
msgstr ""

#. Tag: entry
#: mapping.xml:136
#, no-c-format
msgid "TermVector.NO"
msgstr ""

#. Tag: entry
#: mapping.xml:138
#, no-c-format
msgid "Do not store term vectors."
msgstr ""

#. Tag: entry
#: mapping.xml:142
#, no-c-format
msgid "TermVector.WITH_OFFSETS"
msgstr ""

#. Tag: entry
#: mapping.xml:144
#, no-c-format
msgid ""
"Store the term vector and token offset information. This is the same as "
"TermVector.YES plus it contains the starting and ending offset position "
"information for the terms."
msgstr ""

#. Tag: entry
#: mapping.xml:151
#, no-c-format
msgid "TermVector.WITH_POSITIONS"
msgstr ""

#. Tag: entry
#: mapping.xml:153
#, no-c-format
msgid ""
"Store the term vector and token position information. This is the same as "
"TermVector.YES plus it contains the ordinal positions of each occurrence of "
"a term in a document."
msgstr ""

#. Tag: entry
#: mapping.xml:160
#, no-c-format
msgid "TermVector.WITH_POSITION_OFFSETS"
msgstr ""

#. Tag: entry
#: mapping.xml:162
#, no-c-format
msgid ""
"Store the term vector, token position and offset information. This is a "
"combination of the YES, WITH_OFFSETS and WITH_POSITIONS."
msgstr ""

#. Tag: para
#: mapping.xml:172
#, no-c-format
msgid ""
"Whether or not you want to store the original data in the index depends on "
"how you wish to use the index query result. For a regular Hibernate Search "
"usage storing is not necessary. However you might want to store some fields "
"to subsequently project them (see <xref linkend=\"projections\"/> for more "
"information)."
msgstr ""

#. Tag: para
#: mapping.xml:178
#, no-c-format
msgid ""
"Whether or not you want to tokenize a property depends on whether you wish "
"to search the element as is, or by the words it contains. It make sense to "
"tokenize a text field, but tokenizing a date field probably not. Note that "
"fields used for sorting must not be tokenized."
msgstr ""

#. Tag: para
#: mapping.xml:184
#, no-c-format
msgid ""
"Finally, the id property of an entity is a special property used by "
"Hibernate Search to ensure index unicity of a given entity. By design, an id "
"has to be stored and must not be tokenized. To mark a property as index id, "
"use the <literal>@DocumentId</literal> annotation. If you are using "
"Hibernate Annotations and you have specified @Id you can omit @DocumentId. "
"The chosen entity id will also be used as document id."
msgstr ""

#. Tag: title
#: mapping.xml:193
#, no-c-format
msgid ""
"Adding <classname>@DocumentId</classname> ad <classname>@Field</classname> "
"annotations to an indexed entity"
msgstr ""

#. Tag: programlisting
#: mapping.xml:196
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed(index=\"indexes/essays\")\n"
"public class Essay {\n"
"    ...\n"
"\n"
"    @Id\n"
"    <emphasis role=\"bold\">@DocumentId</emphasis>\n"
"    public Long getId() { return id; }\n"
"\n"
"    <emphasis role=\"bold\">@Field(name=\"Abstract\", index=Index.TOKENIZED, "
"store=Store.YES)</emphasis>\n"
"    public String getSummary() { return summary; }\n"
"\n"
"    @Lob\n"
"    <emphasis role=\"bold\">@Field(index=Index.TOKENIZED)</emphasis>\n"
"    public String getText() { return text; }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:199
#, no-c-format
msgid ""
"The above annotations define an index with three fields: <literal>id</"
"literal> , <literal>Abstract</literal> and <literal>text</literal> . Note "
"that by default the field name is decapitalized, following the JavaBean "
"specification"
msgstr ""

#. Tag: title
#: mapping.xml:206
#, no-c-format
msgid "Mapping properties multiple times"
msgstr ""

#. Tag: para
#: mapping.xml:208
#, no-c-format
msgid ""
"Sometimes one has to map a property multiple times per index, with slightly "
"different indexing strategies. For example, sorting a query by field "
"requires the field to be <literal>UN_TOKENIZED</literal>. If one wants to "
"search by words in this property and still sort it, one need to index it "
"twice - once tokenized and once untokenized. @Fields allows to achieve this "
"goal."
msgstr ""

#. Tag: title
#: mapping.xml:216
#, no-c-format
msgid "Using @Fields to map a property multiple times"
msgstr ""

#. Tag: programlisting
#: mapping.xml:218
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed(index = \"Book\" )\n"
"public class Book {\n"
"    <emphasis role=\"bold\">@Fields( {</emphasis>\n"
"            @Field(index = Index.TOKENIZED),\n"
"            @Field(name = \"summary_forSort\", index = Index.UN_TOKENIZED, "
"store = Store.YES)\n"
"            <emphasis role=\"bold\">} )</emphasis>\n"
"    public String getSummary() {\n"
"        return summary;\n"
"    }\n"
"\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:221
#, no-c-format
msgid ""
"The field <literal>summary</literal> is indexed twice, once as "
"<literal>summary</literal> in a tokenized way, and once as "
"<literal>summary_forSort</literal> in an untokenized way. @Field supports 2 "
"attributes useful when @Fields is used:"
msgstr ""

#. Tag: para
#: mapping.xml:228
#, no-c-format
msgid ""
"analyzer: defines a @Analyzer annotation per field rather than per property"
msgstr ""

#. Tag: para
#: mapping.xml:233
#, no-c-format
msgid ""
"bridge: defines a @FieldBridge annotation per field rather than per property"
msgstr ""

#. Tag: para
#: mapping.xml:238
#, no-c-format
msgid "See below for more information about analyzers and field bridges."
msgstr ""

#. Tag: title
#: mapping.xml:243
#, no-c-format
msgid "Embedded and associated objects"
msgstr ""

#. Tag: para
#: mapping.xml:245
#, no-c-format
msgid ""
"Associated objects as well as embedded objects can be indexed as part of the "
"root entity index. This is useful if you expect to search a given entity "
"based on properties of associated objects. In the following example the aim "
"is to return places where the associated city is Atlanta (In the Lucene "
"query parser language, it would translate into <code>address.city:Atlanta</"
"code>)."
msgstr ""

#. Tag: title
#: mapping.xml:253
#, no-c-format
msgid "Using @IndexedEmbedded to index associations"
msgstr ""

#. Tag: programlisting
#: mapping.xml:255
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Place {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Long id;\n"
"\n"
"    @Field( index = Index.TOKENIZED )\n"
"    private String name;\n"
"\n"
"    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
"    <emphasis role=\"bold\">@IndexedEmbedded</emphasis>\n"
"    private Address address;\n"
"    ....\n"
"}\n"
"\n"
"@Entity\n"
"public class Address {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private Long id;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String street;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String city;\n"
"\n"
"    <emphasis role=\"bold\">@ContainedIn</emphasis>\n"
"    @OneToMany(mappedBy=\"address\")\n"
"    private Set&lt;Place&gt; places;\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:258
#, no-c-format
msgid ""
"In this example, the place fields will be indexed in the <literal>Place</"
"literal> index. The <literal>Place</literal> index documents will also "
"contain the fields <literal>address.id</literal>, <literal>address.street</"
"literal>, and <literal>address.city</literal> which you will be able to "
"query. This is enabled by the <literal>@IndexedEmbedded</literal> annotation."
msgstr ""

#. Tag: para
#: mapping.xml:265
#, no-c-format
msgid ""
"Be careful. Because the data is denormalized in the Lucene index when using "
"the <classname>@IndexedEmbedded</classname> technique, Hibernate Search "
"needs to be aware of any change in the <classname>Place</classname> object "
"and any change in the <classname>Address</classname> object to keep the "
"index up to date. To make sure the <literal><classname>Place</classname></"
"literal> Lucene document is updated when it's <classname>Address</classname> "
"changes, you need to mark the other side of the bidirectional relationship "
"with <classname>@ContainedIn</classname>."
msgstr ""

#. Tag: para
#: mapping.xml:275
#, no-c-format
msgid ""
"<literal>@ContainedIn</literal> is only useful on associations pointing to "
"entities as opposed to embedded (collection of) objects."
msgstr ""

#. Tag: para
#: mapping.xml:279
#, no-c-format
msgid "Let's make our example a bit more complex:"
msgstr ""

#. Tag: title
#: mapping.xml:282
#, no-c-format
msgid ""
"Nested usage of <classname>@IndexedEmbedded</classname> and "
"<classname>@ContainedIn</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:285
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Place {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Long id;\n"
"\n"
"    @Field( index = Index.TOKENIZED )\n"
"    private String name;\n"
"\n"
"    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )\n"
"    <emphasis role=\"bold\">@IndexedEmbedded</emphasis>\n"
"    private Address address;\n"
"    ....\n"
"}\n"
"\n"
"@Entity\n"
"public class Address {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private Long id;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String street;\n"
"\n"
"    @Field(index=Index.TOKENIZED)\n"
"    private String city;\n"
"\n"
"    <emphasis role=\"bold\">@IndexedEmbedded(depth = 1, prefix = \"ownedBy_"
"\")</emphasis>\n"
"    private Owner ownedBy;\n"
"\n"
"    <emphasis role=\"bold\">@ContainedIn</emphasis>\n"
"    @OneToMany(mappedBy=\"address\")\n"
"    private Set&lt;Place&gt; places;\n"
"    ...\n"
"}\n"
"\n"
"@Embeddable\n"
"public class Owner {\n"
"    @Field(index = Index.TOKENIZED)\n"
"    private String name;\n"
"   ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:288
#, no-c-format
msgid ""
"Any <literal>@*ToMany, @*ToOne</literal> and <literal>@Embedded</literal> "
"attribute can be annotated with <literal>@IndexedEmbedded</literal>. The "
"attributes of the associated class will then be added to the main entity "
"index. In the previous example, the index will contain the following fields"
msgstr ""

#. Tag: para
#: mapping.xml:296
#, no-c-format
msgid "<para>id</para>"
msgstr ""

#. Tag: para
#: mapping.xml:300
#, no-c-format
msgid "name"
msgstr ""

#. Tag: para
#: mapping.xml:304
#, no-c-format
msgid "address.street"
msgstr ""

#. Tag: para
#: mapping.xml:308
#, no-c-format
msgid "address.city"
msgstr ""

#. Tag: para
#: mapping.xml:312
#, no-c-format
msgid "address.ownedBy_name"
msgstr ""

#. Tag: para
#: mapping.xml:316
#, no-c-format
msgid ""
"The default prefix is <literal>propertyName.</literal>, following the "
"traditional object navigation convention. You can override it using the "
"<literal>prefix</literal> attribute as it is shown on the <literal>ownedBy</"
"literal> property."
msgstr ""

#. Tag: para
#: mapping.xml:322
#, no-c-format
msgid "The prefix cannot be set to the empty string."
msgstr ""

#. Tag: para
#: mapping.xml:325
#, no-c-format
msgid ""
"The<literal> depth</literal> property is necessary when the object graph "
"contains a cyclic dependency of classes (not instances). For example, if "
"<classname>Owner</classname> points to <classname>Place</classname>. "
"Hibernate Search will stop including Indexed embedded attributes after "
"reaching the expected depth (or the object graph boundaries are reached). A "
"class having a self reference is an example of cyclic dependency. In our "
"example, because <literal>depth</literal> is set to 1, any "
"<literal>@IndexedEmbedded</literal> attribute in Owner (if any) will be "
"ignored."
msgstr ""

#. Tag: para
#: mapping.xml:336
#, no-c-format
msgid ""
"Using <literal>@IndexedEmbedded</literal> for object associations allows you "
"to express queries such as:"
msgstr ""

#. Tag: para
#: mapping.xml:341
#, no-c-format
msgid ""
"Return places where name contains JBoss and where address city is Atlanta. "
"In Lucene query this would be"
msgstr ""

#. Tag: programlisting
#: mapping.xml:344
#, no-c-format
msgid "+name:jboss +address.city:atlanta"
msgstr ""

#. Tag: para
#: mapping.xml:348
#, no-c-format
msgid ""
"Return places where name contains JBoss and where owner's name contain Joe. "
"In Lucene query this would be"
msgstr ""

#. Tag: programlisting
#: mapping.xml:351
#, no-c-format
msgid "+name:jboss +address.orderBy_name:joe"
msgstr ""

#. Tag: para
#: mapping.xml:355
#, no-c-format
msgid ""
"In a way it mimics the relational join operation in a more efficient way (at "
"the cost of data duplication). Remember that, out of the box, Lucene indexes "
"have no notion of association, the join operation is simply non-existent. It "
"might help to keep the relational model normalized while benefiting from the "
"full text index speed and feature richness."
msgstr ""

#. Tag: para
#: mapping.xml:363
#, no-c-format
msgid ""
"An associated object can itself (but does not have to) be <literal>@Indexed</"
"literal>"
msgstr ""

#. Tag: para
#: mapping.xml:367
#, no-c-format
msgid ""
"When @IndexedEmbedded points to an entity, the association has to be "
"directional and the other side has to be annotated <literal>@ContainedIn</"
"literal> (as seen in the previous example). If not, Hibernate Search has no "
"way to update the root index when the associated entity is updated (in our "
"example, a <literal>Place</literal> index document has to be updated when "
"the associated <classname>Address</classname> instance is updated)."
msgstr ""

#. Tag: para
#: mapping.xml:375
#, no-c-format
msgid ""
"Sometimes, the object type annotated by <classname>@IndexedEmbedded</"
"classname> is not the object type targeted by Hibernate and Hibernate "
"Search. This is especially the case when interfaces are used in lieu of "
"their implementation. For this reason you can override the object type "
"targeted by Hibernate Search using the <methodname>targetElement</"
"methodname> parameter."
msgstr ""

#. Tag: title
#: mapping.xml:383
#, no-c-format
msgid ""
"Using the <literal>targetElement</literal> property of "
"<classname>@IndexedEmbedded</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:386
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"public class Address {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Long id;\n"
"\n"
"    @Field(index= Index.TOKENIZED)\n"
"    private String street;\n"
"\n"
"    @IndexedEmbedded(depth = 1, prefix = \"ownedBy_\", <emphasis role=\"bold"
"\">targetElement = Owner.class</emphasis>)\n"
"    @Target(Owner.class)\n"
"    private Person ownedBy;\n"
"\n"
"\n"
"    ...\n"
"}\n"
"\n"
"@Embeddable\n"
"public class Owner implements Person { ... }"
msgstr ""

#. Tag: title
#: mapping.xml:391
#, no-c-format
msgid "Boost factor"
msgstr ""

#. Tag: para
#: mapping.xml:393
#, no-c-format
msgid ""
"Lucene has the notion of <emphasis>boost factor</emphasis>. It's a way to "
"give more weight to a field or to an indexed element over others during the "
"indexation process. You can use <literal>@Boost</literal> at the @Field, "
"method or class level."
msgstr ""

#. Tag: title
#: mapping.xml:399
#, no-c-format
msgid ""
"Using different ways of increasing the weight of an indexed element using a "
"boost factor"
msgstr ""

#. Tag: programlisting
#: mapping.xml:402
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed(index=\"indexes/essays\")\n"
"<emphasis role=\"bold\">@Boost(1.7f)</emphasis>\n"
"public class Essay {\n"
"    ...\n"
"\n"
"    @Id\n"
"    @DocumentId\n"
"    public Long getId() { return id; }\n"
"\n"
"    @Field(name=\"Abstract\", index=Index.TOKENIZED, store=Store.YES, "
"boost=<emphasis\n"
"            role=\"bold\">@Boost(2f)</emphasis>)\n"
"    <emphasis role=\"bold\">@Boost(1.5f)</emphasis>\n"
"    public String getSummary() { return summary; }\n"
"\n"
"    @Lob\n"
"    @Field(index=Index.TOKENIZED, boost=<emphasis role=\"bold\">@Boost(1.2f)"
"</emphasis>)\n"
"    public String getText() { return text; }\n"
"\n"
"    @Field\n"
"    public String getISBN() { return isbn; }\n"
"\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:405
#, no-c-format
msgid ""
"In our example, <classname>Essay</classname>'s probability to reach the top "
"of the search list will be multiplied by 1.7. The <methodname>summary</"
"methodname> field will be 3.0 (2 * 1.5 - <methodname>@Field.boost</"
"methodname> and <classname>@Boost</classname> on a property are cumulative) "
"more important than the <methodname>isbn</methodname> field. The "
"<methodname>text</methodname> field will be 1.2 times more important than "
"the <methodname>isbn</methodname> field. Note that this explanation in "
"strictest terms is actually wrong, but it is simple and close enough to "
"reality for all practical purposes. Please check the Lucene documentation or "
"the excellent <citetitle>Lucene In Action </citetitle> from Otis Gospodnetic "
"and Erik Hatcher."
msgstr ""

#. Tag: title
#: mapping.xml:420
#, no-c-format
msgid "Analyzer"
msgstr ""

#. Tag: para
#: mapping.xml:422
#, no-c-format
msgid ""
"The default analyzer class used to index tokenized fields is configurable "
"through the <literal>hibernate.search.analyzer</literal> property. The "
"default value for this property is <classname>org.apache.lucene.analysis."
"standard.StandardAnalyzer</classname>."
msgstr ""

#. Tag: para
#: mapping.xml:427
#, no-c-format
msgid ""
"You can also define the analyzer class per entity, property and even per "
"@Field (useful when multiple fields are indexed from a single property)."
msgstr ""

#. Tag: title
#: mapping.xml:432
#, no-c-format
msgid "Different ways of specifying an analyzer"
msgstr ""

#. Tag: programlisting
#: mapping.xml:434
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"<emphasis role=\"bold\">@Analyzer(impl = EntityAnalyzer.class)</emphasis>\n"
"public class MyEntity {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Integer id;\n"
"\n"
"    @Field(index = Index.TOKENIZED)\n"
"    private String name;\n"
"\n"
"    @Field(index = Index.TOKENIZED)\n"
"    <emphasis role=\"bold\">@Analyzer(impl = PropertyAnalyzer.class)</"
"emphasis>\n"
"    private String summary;\n"
"\n"
"    @Field(index = Index.TOKENIZED, <emphasis><emphasis role=\"bold"
"\">analyzer = @Analyzer(impl = FieldAnalyzer.class</emphasis>)</emphasis>\n"
"    private String body;\n"
"\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:437
#, no-c-format
msgid ""
"In this example, <classname>EntityAnalyzer</classname> is used to index all "
"tokenized properties (eg. <literal>name</literal>), except <literal>summary</"
"literal> and <literal>body</literal> which are indexed with "
"<classname>PropertyAnalyzer</classname> and <classname>FieldAnalyzer</"
"classname> respectively."
msgstr ""

#. Tag: para
#: mapping.xml:444
#, no-c-format
msgid ""
"Mixing different analyzers in the same entity is most of the time a bad "
"practice. It makes query building more complex and results less predictable "
"(for the novice), especially if you are using a QueryParser (which uses the "
"same analyzer for the whole query). As a rule of thumb, for any given field "
"the same analyzer should be used for indexing and querying."
msgstr ""

#. Tag: title
#: mapping.xml:453
#, no-c-format
msgid "Analyzer definitions"
msgstr ""

#. Tag: para
#: mapping.xml:455
#, no-c-format
msgid ""
"Analyzers can become quite complex to deal with for which reason Hibernate "
"Search introduces the notion of analyzer definitions. An analyzer definition "
"can be reused by many <classname>@Analyzer</classname> declarations. An "
"analyzer definition is composed of:"
msgstr ""

#. Tag: para
#: mapping.xml:463
#, no-c-format
msgid "a name: the unique string used to refer to the definition"
msgstr ""

#. Tag: para
#: mapping.xml:468
#, no-c-format
msgid ""
"a tokenizer: responsible for tokenizing the input stream into individual "
"words"
msgstr ""

#. Tag: para
#: mapping.xml:473
#, no-c-format
msgid ""
"a list of filters: each filter is responsible to remove, modify or sometimes "
"even add words into the stream provided by the tokenizer"
msgstr ""

#. Tag: para
#: mapping.xml:479
#, no-c-format
msgid ""
"This separation of tasks - a tokenizer followed by a list of filters - "
"allows for easy reuse of each individual component and let you build your "
"customized analyzer in a very flexible way (just like Lego). Generally "
"speaking the <classname>Tokenizer</classname> starts the analysis process by "
"turning the character input into tokens which are then further processed by "
"the <classname>TokenFilter</classname>s. Hibernate Search supports this "
"infrastructure by utilizing the Solr analyzer framework. Make sure to "
"add<filename> solr-core.jar and </filename><filename>solr-common.jar</"
"filename> to your classpath to use analyzer definitions. In case you also "
"want to utilizing a snowball stemmer also include the <filename>lucene-"
"snowball.jar.</filename> Other Solr analyzers might depend on more "
"libraries. For example, the <classname>PhoneticFilterFactory</classname> "
"depends on <ulink url=\"http://commons.apache.org/codec\">commons-codec</"
"ulink>. Your distribution of Hibernate Search provides these dependencies in "
"its <filename>lib</filename> directory."
msgstr ""

#. Tag: title
#: mapping.xml:498
#, no-c-format
msgid "<classname>@AnalyzerDef</classname> and the Solr framework"
msgstr ""

#. Tag: programlisting
#: mapping.xml:501
#, no-c-format
msgid ""
"@AnalyzerDef(name=\"customanalyzer\",\n"
"        tokenizer = @TokenizerDef(factory = StandardTokenizerFactory."
"class),\n"
"        filters = {\n"
"                @TokenFilterDef(factory = ISOLatin1AccentFilterFactory."
"class),\n"
"                @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"                @TokenFilterDef(factory = StopFilterFactory.class, params = "
"{\n"
"                    @Parameter(name=\"words\", value= \"org/hibernate/search/"
"test/analyzer/solr/stoplist.properties\" ),\n"
"                    @Parameter(name=\"ignoreCase\", value=\"true\")\n"
"                })\n"
"})\n"
"public class Team {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:504
#, no-c-format
msgid ""
"A tokenizer is defined by its factory which is responsible for building the "
"tokenizer and using the optional list of parameters. This example use the "
"standard tokenizer. A filter is defined by its factory which is responsible "
"for creating the filter instance using the optional parameters. In our "
"example, the StopFilter filter is built reading the dedicated words property "
"file and is expected to ignore case. The list of parameters is dependent on "
"the tokenizer or filter factory."
msgstr ""

#. Tag: para
#: mapping.xml:514
#, no-c-format
msgid ""
"Filters are applied in the order they are defined in the "
"<classname>@AnalyzerDef</classname> annotation. Make sure to think twice "
"about this order."
msgstr ""

#. Tag: para
#: mapping.xml:519
#, no-c-format
msgid ""
"Once defined, an analyzer definition can be reused by an "
"<classname>@Analyzer</classname> declaration using the definition name "
"rather than declaring an implementation class."
msgstr ""

#. Tag: title
#: mapping.xml:524
#, no-c-format
msgid "Referencing an analyzer by name"
msgstr ""

#. Tag: programlisting
#: mapping.xml:526
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@AnalyzerDef(name=\"customanalyzer\", ... )\n"
"public class Team {\n"
"    @Id\n"
"    @DocumentId\n"
"    @GeneratedValue\n"
"    private Integer id;\n"
"\n"
"    @Field\n"
"    private String name;\n"
"\n"
"    @Field\n"
"    private String location;\n"
"\n"
"    @Field <emphasis role=\"bold\">@Analyzer(definition = \"customanalyzer\")"
"</emphasis>\n"
"    private String description;\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:529
#, no-c-format
msgid ""
"Analyzer instances declared by <classname>@AnalyzerDef</classname> are "
"available by their name in the <classname>SearchFactory</classname>."
msgstr ""

#. Tag: programlisting
#: mapping.xml:533
#, no-c-format
msgid ""
"Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer"
"(\"customanalyzer\");"
msgstr ""

#. Tag: para
#: mapping.xml:535
#, no-c-format
msgid ""
"This is quite useful wen building queries. Fields in queries should be "
"analyzed with the same analyzer used to index the field so that they speak a "
"common \"language\": the same tokens are reused between the query and the "
"indexing process. This rule has some exceptions but is true most of the "
"time. Respect it unless you know what you are doing."
msgstr ""

#. Tag: title
#: mapping.xml:544
#, no-c-format
msgid "Available analyzers"
msgstr ""

#. Tag: para
#: mapping.xml:546
#, no-c-format
msgid ""
"Solr and Lucene come with a lot of useful default tokenizers and filters. "
"You can find a complete list of tokenizer factories and filter factories at "
"<ulink url=\"http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters"
"\">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</ulink>. Let "
"check a few of them."
msgstr ""

#. Tag: title
#: mapping.xml:553
#, no-c-format
msgid "Some of the available tokenizers"
msgstr ""

#. Tag: entry
#: mapping.xml:558 mapping.xml:593
#, no-c-format
msgid "Factory"
msgstr ""

#. Tag: entry
#: mapping.xml:560 mapping.xml:595
#, no-c-format
msgid "Description"
msgstr ""

#. Tag: entry
#: mapping.xml:562 mapping.xml:597
#, no-c-format
msgid "parameters"
msgstr ""

#. Tag: entry
#: mapping.xml:568
#, no-c-format
msgid "StandardTokenizerFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:570
#, no-c-format
msgid "Use the Lucene StandardTokenizer"
msgstr ""

#. Tag: entry
#: mapping.xml:572 mapping.xml:581 mapping.xml:607 mapping.xml:615
#: mapping.xml:647
#, no-c-format
msgid "none"
msgstr ""

#. Tag: entry
#: mapping.xml:576
#, no-c-format
msgid "HTMLStripStandardTokenizerFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:578
#, no-c-format
msgid "Remove HTML tags, keep the text and pass it to a StandardTokenizer"
msgstr ""

#. Tag: title
#: mapping.xml:588
#, no-c-format
msgid "Some of the available filters"
msgstr ""

#. Tag: entry
#: mapping.xml:603
#, no-c-format
msgid "StandardFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:605
#, no-c-format
msgid "Remove dots from acronyms and 's from words"
msgstr ""

#. Tag: entry
#: mapping.xml:611
#, no-c-format
msgid "LowerCaseFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:613
#, no-c-format
msgid "Lowercase words"
msgstr ""

#. Tag: entry
#: mapping.xml:619
#, no-c-format
msgid "StopFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:621
#, no-c-format
msgid "remove words (tokens) matching a list of stop words"
msgstr ""

#. Tag: para
#: mapping.xml:624
#, no-c-format
msgid ""
"<literal>words</literal>: points to a resource file containing the stop words"
msgstr ""

#. Tag: para
#: mapping.xml:625
#, no-c-format
msgid ""
"ignoreCase: true if <literal>case</literal> should be ignore when comparing "
"stop words, <literal>false</literal> otherwise"
msgstr ""

#. Tag: entry
#: mapping.xml:631
#, no-c-format
msgid "SnowballPorterFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:633
#, no-c-format
msgid ""
"Reduces a word to it's root in a given language. (eg. protect, protects, "
"protection share the same root). Using such a filter allows searches "
"matching related words."
msgstr ""

#. Tag: entry
#: mapping.xml:637
#, no-c-format
msgid ""
"<literal>language</literal>: Danish, Dutch, English, Finnish, French, "
"German, Italian, Norwegian, Portuguese, Russian, Spanish, Swedish and a few "
"more"
msgstr ""

#. Tag: entry
#: mapping.xml:643
#, no-c-format
msgid "ISOLatin1AccentFilterFactory"
msgstr ""

#. Tag: entry
#: mapping.xml:645
#, no-c-format
msgid "remove accents for languages like French"
msgstr ""

#. Tag: para
#: mapping.xml:653
#, no-c-format
msgid ""
"We recommend to check all the implementations of <classname>org.apache.solr."
"analysis.TokenizerFactory</classname> and <classname>org.apache.solr."
"analysis.TokenFilterFactory</classname> in your IDE to see the "
"implementations available."
msgstr ""

#. Tag: title
#: mapping.xml:660
#, no-c-format
msgid "Analyzer discriminator (experimental)"
msgstr ""

#. Tag: para
#: mapping.xml:662
#, no-c-format
msgid ""
"So far all the introduced ways to specify an analyzer were static. However, "
"there are use cases where it is useful to select an analyzer depending on "
"the current state of the entity to be indexed, for example in multilingual "
"application. For an <classname>BlogEntry</classname> class for example the "
"analyzer could depend on the language property of the entry. Depending on "
"this property the correct language specific stemmer should be chosen to "
"index the actual text."
msgstr ""

#. Tag: para
#: mapping.xml:671
#, no-c-format
msgid ""
"To enable this dynamic analyzer selection Hibernate Search introduces the "
"<classname>AnalyzerDiscriminator</classname> annotation. The following "
"example demonstrates the usage of this annotation:"
msgstr ""

#. Tag: title
#: mapping.xml:677
#, no-c-format
msgid ""
"Usage of @AnalyzerDiscriminator in order to select an analyzer depending on "
"the entity state"
msgstr ""

#. Tag: programlisting
#: mapping.xml:680
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"@AnalyzerDefs({\n"
"  @AnalyzerDef(name = \"en\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = EnglishPorterFilterFactory.class\n"
"      )\n"
"    }),\n"
"  @AnalyzerDef(name = \"de\",\n"
"    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),\n"
"    filters = {\n"
"      @TokenFilterDef(factory = LowerCaseFilterFactory.class),\n"
"      @TokenFilterDef(factory = GermanStemFilterFactory.class)\n"
"    })\n"
"})\n"
"public class BlogEntry {\n"
"\n"
"    @Id\n"
"    @GeneratedValue\n"
"    @DocumentId\n"
"    private Integer id;\n"
"\n"
"    @Field\n"
"    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)\n"
"    private String language;\n"
"    \n"
"    @Field\n"
"    private String text;\n"
"    \n"
"    private Set&lt;BlogEntry&gt; references;\n"
"\n"
"    // standard getter/setter\n"
"    ...\n"
"}"
msgstr ""

#. Tag: programlisting
#: mapping.xml:682
#, no-c-format
msgid ""
"public class LanguageDiscriminator implements Discriminator {\n"
"\n"
"    public String getAnalyzerDefinitionName(Object value, Object entity, "
"String field) {\n"
"        if ( value == null || !( entity instanceof Article ) ) {\n"
"            return null;\n"
"        }\n"
"        return (String) value;\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:685
#, no-c-format
msgid ""
"The prerequisite for using <classname>@AnalyzerDiscriminator</classname> is "
"that all analyzers which are going to be used are predefined via "
"<classname>@AnalyzerDef</classname> definitions. If this is the case one can "
"place the <classname>@AnalyzerDiscriminator</classname> annotation either on "
"the class or on a specific property of the entity for which to dynamically "
"select an analyzer. Via the <literal>impl</literal> parameter of the "
"<classname>AnalyzerDiscriminator</classname> you specify a concrete "
"implementation of the <classname>Discriminator</classname> interface. It is "
"up to you to provide an implementation for this interface. The only method "
"you have to implement is <classname>getAnalyzerDefinitionName()</classname> "
"which gets called for each field added to the Lucene document. The entity "
"which is getting indexed is also passed to the interface method. The "
"<literal>value</literal> parameter is only set if the "
"<classname>AnalyzerDiscriminator</classname> is placed on property level "
"instead of class level. In this case the value represents the current value "
"of this property."
msgstr ""

#. Tag: para
#: mapping.xml:705
#, no-c-format
msgid ""
"An implemention of the <classname>Discriminator</classname> interface has to "
"return the name of an existing analyzer definition if the analyzer should be "
"set dynamically or <classname>null</classname> if the default analyzer "
"should not be overridden. The given example assumes that the language "
"parameter is either 'de' or 'en' which matches the specified names in the "
"<classname>@AnalyzerDef</classname>s."
msgstr ""

#. Tag: para
#: mapping.xml:714
#, no-c-format
msgid ""
"The <classname>@AnalyzerDiscriminator</classname> is currently still "
"experimental and the API might still change. We are hoping for some feedback "
"from the community about the usefulness and usability of this feature."
msgstr ""

#. Tag: title
#: mapping.xml:722
#, no-c-format
msgid "Retrieving an analyzer"
msgstr ""

#. Tag: para
#: mapping.xml:724
#, no-c-format
msgid ""
"During indexing time, Hibernate Search is using analyzers under the hood for "
"you. In some situations, retrieving analyzers can be handy. If your domain "
"model makes use of multiple analyzers (maybe to benefit from stemming, use "
"phonetic approximation and so on), you need to make sure to use the same "
"analyzers when you build your query."
msgstr ""

#. Tag: para
#: mapping.xml:732
#, no-c-format
msgid ""
"This rule can be broken but you need a good reason for it. If you are "
"unsure, use the same analyzers."
msgstr ""

#. Tag: para
#: mapping.xml:736
#, no-c-format
msgid ""
"You can retrieve the scoped analyzer for a given entity used at indexing "
"time by Hibernate Search. A scoped analyzer is an analyzer which applies the "
"right analyzers depending on the field indexed: multiple analyzers can be "
"defined on a given entity each one working on an individual field, a scoped "
"analyzer unify all these analyzers into a context-aware analyzer. While the "
"theory seems a bit complex, using the right analyzer in a query is very easy."
msgstr ""

#. Tag: title
#: mapping.xml:745
#, no-c-format
msgid "Using the scoped analyzer when building a full-text query"
msgstr ""

#. Tag: programlisting
#: mapping.xml:748
#, no-c-format
msgid ""
"org.apache.lucene.queryParser.QueryParser parser = new QueryParser(\n"
"    \"title\", \n"
"    fullTextSession.getSearchFactory().getAnalyzer( Song.class )\n"
");\n"
"\n"
"org.apache.lucene.search.Query luceneQuery = \n"
"    parser.parse( \"title:sky Or title_stemmed:diamond\" );\n"
"\n"
"org.hibernate.Query fullTextQuery = \n"
"    fullTextSession.createFullTextQuery( luceneQuery, Song.class );\n"
"\n"
"List result = fullTextQuery.list(); //return a list of managed objects"
msgstr ""

#. Tag: para
#: mapping.xml:751
#, no-c-format
msgid ""
"In the example above, the song title is indexed in two fields: the standard "
"analyzer is used in the field <literal>title</literal> and a stemming "
"analyzer is used in the field <literal>title_stemmed</literal>. By using the "
"analyzer provided by the search factory, the query uses the appropriate "
"analyzer depending on the field targeted."
msgstr ""

#. Tag: para
#: mapping.xml:758
#, no-c-format
msgid ""
"If your query targets more that one query and you wish to use your standard "
"analyzer, make sure to describe it using an analyzer definition. You can "
"retrieve analyzers by their definition name using <code>searchFactory."
"getAnalyzer(String)</code>."
msgstr ""

#. Tag: title
#: mapping.xml:767
#, no-c-format
msgid "Property/Field Bridge"
msgstr ""

#. Tag: para
#: mapping.xml:769
#, no-c-format
msgid ""
"In Lucene all index fields have to be represented as Strings. For this "
"reason all entity properties annotated with <literal>@Field</literal> have "
"to be indexed in a String form. For most of your properties, Hibernate "
"Search does the translation job for you thanks to a built-in set of bridges. "
"In some cases, though you need a more fine grain control over the "
"translation process."
msgstr ""

#. Tag: title
#: mapping.xml:777
#, no-c-format
msgid "Built-in bridges"
msgstr ""

#. Tag: para
#: mapping.xml:779
#, no-c-format
msgid ""
"Hibernate Search comes bundled with a set of built-in bridges between a Java "
"property type and its full text representation."
msgstr ""

#. Tag: term
#: mapping.xml:784
#, no-c-format
msgid "null"
msgstr ""

#. Tag: para
#: mapping.xml:787
#, no-c-format
msgid ""
"null elements are not indexed. Lucene does not support null elements and "
"this does not make much sense either."
msgstr ""

#. Tag: term
#: mapping.xml:793
#, no-c-format
msgid "java.lang.String"
msgstr ""

#. Tag: para
#: mapping.xml:796
#, no-c-format
msgid "String are indexed as is"
msgstr ""

#. Tag: term
#: mapping.xml:801
#, no-c-format
msgid ""
"short, Short, integer, Integer, long, Long, float, Float, double, Double, "
"BigInteger, BigDecimal"
msgstr ""

#. Tag: para
#: mapping.xml:805
#, no-c-format
msgid ""
"Numbers are converted in their String representation. Note that numbers "
"cannot be compared by Lucene (ie used in ranged queries) out of the box: "
"they have to be padded"
msgstr ""

#. Tag: para
#: mapping.xml:808
#, no-c-format
msgid ""
"Using a Range query is debatable and has drawbacks, an alternative approach "
"is to use a Filter query which will filter the result query to the "
"appropriate range."
msgstr ""

#. Tag: para
#: mapping.xml:812
#, no-c-format
msgid "Hibernate Search will support a padding mechanism"
msgstr ""

#. Tag: term
#: mapping.xml:818
#, no-c-format
msgid "java.util.Date"
msgstr ""

#. Tag: para
#: mapping.xml:821
#, no-c-format
msgid ""
"Dates are stored as yyyyMMddHHmmssSSS in GMT time (200611072203012 for Nov "
"7th of 2006 4:03PM and 12ms EST). You shouldn't really bother with the "
"internal format. What is important is that when using a DateRange Query, you "
"should know that the dates have to be expressed in GMT time."
msgstr ""

#. Tag: para
#: mapping.xml:827
#, no-c-format
msgid ""
"Usually, storing the date up to the millisecond is not necessary. "
"<literal>@DateBridge</literal> defines the appropriate resolution you are "
"willing to store in the index ( <literal> <literal>@DateBridge"
"(resolution=Resolution.DAY)</literal> </literal> ). The date pattern will "
"then be truncated accordingly."
msgstr ""

#. Tag: programlisting
#: mapping.xml:834
#, no-c-format
msgid ""
"@Entity \n"
"@Indexed\n"
"public class Meeting {\n"
"    @Field(index=Index.UN_TOKENIZED)\n"
"    <emphasis role=\"bold\">@DateBridge(resolution=Resolution.MINUTE)</"
"emphasis>\n"
"    private Date date;\n"
"    ..."
msgstr ""

#. Tag: para
#: mapping.xml:837
#, no-c-format
msgid ""
"A Date whose resolution is lower than <literal>MILLISECOND</literal> cannot "
"be a <literal>@DocumentId</literal>"
msgstr ""

#. Tag: term
#: mapping.xml:845
#, no-c-format
msgid "java.net.URI, java.net.URL"
msgstr ""

#. Tag: para
#: mapping.xml:848
#, no-c-format
msgid "URI and URL are converted to their string representation"
msgstr ""

#. Tag: term
#: mapping.xml:854
#, no-c-format
msgid "java.lang.Class"
msgstr ""

#. Tag: para
#: mapping.xml:857
#, no-c-format
msgid ""
"Class are converted to their fully qualified class name. The thread context "
"classloader is used when the class is rehydrated"
msgstr ""

#. Tag: title
#: mapping.xml:866
#, no-c-format
msgid "Custom Bridge"
msgstr ""

#. Tag: para
#: mapping.xml:868
#, no-c-format
msgid ""
"Sometimes, the built-in bridges of Hibernate Search do not cover some of "
"your property types, or the String representation used by the bridge does "
"not meet your requirements. The following paragraphs describe several "
"solutions to this problem."
msgstr ""

#. Tag: title
#: mapping.xml:874
#, no-c-format
msgid "StringBridge"
msgstr ""

#. Tag: para
#: mapping.xml:876
#, no-c-format
msgid ""
"The simplest custom solution is to give Hibernate Search an implementation "
"of your expected <emphasis><classname>Object</classname> </emphasis>to "
"<classname>String</classname> bridge. To do so you need to implements the "
"<literal>org.hibernate.search.bridge.StringBridge</literal> interface. All "
"implementations have to be thread-safe as they are used concurrently."
msgstr ""

#. Tag: title
#: mapping.xml:885
#, no-c-format
msgid "Implementing your own <classname>StringBridge</classname>"
msgstr ""

#. Tag: programlisting
#: mapping.xml:888
#, no-c-format
msgid ""
"/**\n"
" * Padding Integer bridge.\n"
" * All numbers will be padded with 0 to match 5 digits\n"
" *\n"
" * @author Emmanuel Bernard\n"
" */\n"
"public class PaddedIntegerBridge implements <emphasis role=\"bold"
"\">StringBridge</emphasis> {\n"
"\n"
"    private int PADDING = 5;\n"
"\n"
"    <emphasis role=\"bold\">public String objectToString(Object object)</"
"emphasis> {\n"
"        String rawInteger = ( (Integer) object ).toString();\n"
"        if (rawInteger.length() &gt; PADDING) \n"
"            throw new IllegalArgumentException( \"Try to pad on a number too "
"big\" );\n"
"        StringBuilder paddedInteger = new StringBuilder( );\n"
"        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; "
"padIndex++ ) {\n"
"            paddedInteger.append('0');\n"
"        }\n"
"        return paddedInteger.append( rawInteger ).toString();\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:891
#, no-c-format
msgid ""
"Then any property or field can use this bridge thanks to the "
"<literal>@FieldBridge</literal> annotation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:894
#, no-c-format
msgid ""
"<emphasis role=\"bold\">@FieldBridge(impl = PaddedIntegerBridge.class)</"
"emphasis>\n"
"private Integer length;"
msgstr ""

#. Tag: para
#: mapping.xml:896
#, no-c-format
msgid ""
"Parameters can be passed to the Bridge implementation making it more "
"flexible. The Bridge implementation implements a "
"<classname>ParameterizedBridge</classname> interface, and the parameters are "
"passed through the <literal>@FieldBridge</literal> annotation."
msgstr ""

#. Tag: title
#: mapping.xml:903
#, no-c-format
msgid "Passing parameters to your bridge implementation"
msgstr ""

#. Tag: programlisting
#: mapping.xml:905
#, no-c-format
msgid ""
"public class PaddedIntegerBridge implements StringBridge, <emphasis\n"
"              role=\"bold\">ParameterizedBridge</emphasis> {\n"
"\n"
"    public static String PADDING_PROPERTY = \"padding\";\n"
"    private int padding = 5; //default\n"
"\n"
"    <emphasis role=\"bold\">public void setParameterValues(Map parameters)</"
"emphasis> {\n"
"        Object padding = parameters.get( PADDING_PROPERTY );\n"
"        if (padding != null) this.padding = (Integer) padding;\n"
"    }\n"
"\n"
"    public String objectToString(Object object) {\n"
"        String rawInteger = ( (Integer) object ).toString();\n"
"        if (rawInteger.length() &gt; padding) \n"
"            throw new IllegalArgumentException( \"Try to pad on a number too "
"big\" );\n"
"        StringBuilder paddedInteger = new StringBuilder( );\n"
"        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; "
"padIndex++ ) {\n"
"            paddedInteger.append('0');\n"
"        }\n"
"        return paddedInteger.append( rawInteger ).toString();\n"
"    }\n"
"}\n"
"\n"
"\n"
"//property\n"
"@FieldBridge(impl = PaddedIntegerBridge.class,\n"
"             <emphasis role=\"bold\">params = @Parameter(name=\"padding\", "
"value=\"10\")</emphasis>\n"
"            )\n"
"private Integer length;"
msgstr ""

#. Tag: para
#: mapping.xml:908
#, no-c-format
msgid ""
"The <classname>ParameterizedBridge</classname> interface can be implemented "
"by <classname>StringBridge</classname>, <classname>TwoWayStringBridge</"
"classname>, <classname>FieldBridge</classname> implementations."
msgstr ""

#. Tag: para
#: mapping.xml:913
#, no-c-format
msgid ""
"All implementations have to be thread-safe, but the parameters are set "
"during initialization and no special care is required at this stage."
msgstr ""

#. Tag: para
#: mapping.xml:917
#, no-c-format
msgid ""
"If you expect to use your bridge implementation on an id property (ie "
"annotated with <literal>@DocumentId</literal> ), you need to use a slightly "
"extended version of <literal>StringBridge</literal> named "
"<classname>TwoWayStringBridge</classname>. Hibernate Search needs to read "
"the string representation of the identifier and generate the object out of "
"it. There is not difference in the way the <literal>@FieldBridge</literal> "
"annotation is used."
msgstr ""

#. Tag: title
#: mapping.xml:926
#, no-c-format
msgid ""
"Implementing a TwoWayStringBridge which can for example be used for id "
"properties"
msgstr ""

#. Tag: programlisting
#: mapping.xml:929
#, no-c-format
msgid ""
"public class PaddedIntegerBridge implements TwoWayStringBridge, "
"ParameterizedBridge {\n"
"\n"
"    public static String PADDING_PROPERTY = \"padding\";\n"
"    private int padding = 5; //default\n"
"\n"
"    public void setParameterValues(Map parameters) {\n"
"        Object padding = parameters.get( PADDING_PROPERTY );\n"
"        if (padding != null) this.padding = (Integer) padding;\n"
"    }\n"
"\n"
"    public String objectToString(Object object) {\n"
"        String rawInteger = ( (Integer) object ).toString();\n"
"        if (rawInteger.length() &gt; padding) \n"
"            throw new IllegalArgumentException( \"Try to pad on a number too "
"big\" );\n"
"        StringBuilder paddedInteger = new StringBuilder( );\n"
"        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; "
"padIndex++ ) {\n"
"            paddedInteger.append('0');\n"
"        }\n"
"        return paddedInteger.append( rawInteger ).toString();\n"
"    }\n"
"\n"
"    <emphasis role=\"bold\">public Object stringToObject(String stringValue)"
"</emphasis> {\n"
"        return new Integer(stringValue);\n"
"    }\n"
"}\n"
"\n"
"\n"
"//id property\n"
"@DocumentId\n"
"@FieldBridge(impl = PaddedIntegerBridge.class,\n"
"             params = @Parameter(name=\"padding\", value=\"10\") \n"
"private Integer id;"
msgstr ""

#. Tag: para
#: mapping.xml:932
#, no-c-format
msgid ""
"It is critically important for the two-way process to be idempotent (ie "
"object = stringToObject( objectToString( object ) ) )."
msgstr ""

#. Tag: title
#: mapping.xml:938
#, no-c-format
msgid "FieldBridge"
msgstr ""

#. Tag: para
#: mapping.xml:940
#, no-c-format
msgid ""
"Some use cases require more than a simple object to string translation when "
"mapping a property to a Lucene index. To give you the greatest possible "
"flexibility you can also implement a bridge as a <classname>FieldBridge</"
"classname>. This interface gives you a property value and let you map it the "
"way you want in your Lucene <classname>Document</classname>.The interface is "
"very similar in its concept to the Hibernate<classname> UserType</"
"classname>s."
msgstr ""

#. Tag: para
#: mapping.xml:948
#, no-c-format
msgid ""
"You can for example store a given property in two different document fields:"
msgstr ""

#. Tag: title
#: mapping.xml:952
#, no-c-format
msgid ""
"Implementing the FieldBridge interface in order to a given property into "
"multiple document fields"
msgstr ""

#. Tag: programlisting
#: mapping.xml:955
#, no-c-format
msgid ""
"/**\n"
" * Store the date in 3 different fields - year, month, day - to ease Range "
"Query per\n"
" * year, month or day (eg get all the elements of December for the last 5 "
"years).\n"
" * \n"
" * @author Emmanuel Bernard\n"
" */\n"
"public class DateSplitBridge implements FieldBridge {\n"
"    private final static TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n"
"\n"
"    <emphasis role=\"bold\">public void set(String name, Object value, "
"Document document, \n"
"                    LuceneOptions luceneOptions)</emphasis> {\n"
"        Date date = (Date) value;\n"
"        Calendar cal = GregorianCalendar.getInstance(GMT);\n"
"        cal.setTime(date);\n"
"        int year = cal.get(Calendar.YEAR);\n"
"        int month = cal.get(Calendar.MONTH) + 1;\n"
"        int day = cal.get(Calendar.DAY_OF_MONTH);\n"
"  \n"
"        // set year\n"
"        Field field = new Field(name + \".year\", String.valueOf(year),\n"
"            luceneOptions.getStore(), luceneOptions.getIndex(),\n"
"            luceneOptions.getTermVector());\n"
"        field.setBoost(luceneOptions.getBoost());\n"
"        document.add(field);\n"
"  \n"
"        // set month and pad it if needed\n"
"        field = new Field(name + \".month\", month &lt; 10 ? \"0\" : \"\"\n"
"            + String.valueOf(month), luceneOptions.getStore(),\n"
"            luceneOptions.getIndex(), luceneOptions.getTermVector());\n"
"        field.setBoost(luceneOptions.getBoost());\n"
"        document.add(field);\n"
"  \n"
"        // set day and pad it if needed\n"
"        field = new Field(name + \".day\", day &lt; 10 ? \"0\" : \"\"\n"
"            + String.valueOf(day), luceneOptions.getStore(),\n"
"            luceneOptions.getIndex(), luceneOptions.getTermVector());\n"
"        field.setBoost(luceneOptions.getBoost());\n"
"        document.add(field);\n"
"    }\n"
"}\n"
"\n"
"//property\n"
"<emphasis role=\"bold\">@FieldBridge(impl = DateSplitBridge.class)</"
"emphasis>\n"
"private Date date;"
msgstr ""

#. Tag: title
#: mapping.xml:960
#, no-c-format
msgid "ClassBridge"
msgstr ""

#. Tag: para
#: mapping.xml:962
#, no-c-format
msgid ""
"It is sometimes useful to combine more than one property of a given entity "
"and index this combination in a specific way into the Lucene index. The "
"<classname>@ClassBridge</classname> and <classname>@ClassBridge</classname> "
"annotations can be defined at the class level (as opposed to the property "
"level). In this case the custom field bridge implementation receives the "
"entity instance as the value parameter instead of a particular property. "
"Though not shown in this example, <classname>@ClassBridge</classname> "
"supports the <methodname>termVector</methodname> attribute discussed in "
"section <xref linkend=\"basic-mapping\"/>."
msgstr ""

#. Tag: title
#: mapping.xml:974
#, no-c-format
msgid "Implementing a class bridge"
msgstr ""

#. Tag: programlisting
#: mapping.xml:976
#, no-c-format
msgid ""
"@Entity\n"
"@Indexed\n"
"<emphasis role=\"bold\">@ClassBridge</emphasis>(name=\"branchnetwork\",\n"
"             index=Index.TOKENIZED,\n"
"             store=Store.YES,\n"
"             impl = <emphasis role=\"bold\">CatFieldsClassBridge.class</"
"emphasis>,\n"
"             params = @Parameter( name=\"sepChar\", value=\" \" ) )\n"
"public class Department {\n"
"    private int id;\n"
"    private String network;\n"
"    private String branchHead;\n"
"    private String branch;\n"
"    private Integer maxEmployees\n"
"    ...\n"
"}\n"
"\n"
"\n"
"public class CatFieldsClassBridge implements FieldBridge, "
"ParameterizedBridge {\n"
"    private String sepChar;\n"
"\n"
"    public void setParameterValues(Map parameters) {\n"
"        this.sepChar = (String) parameters.get( \"sepChar\" );\n"
"    }\n"
"\n"
"    <emphasis role=\"bold\">public void set(String name, Object value, "
"Document document, LuceneOptions luceneOptions)</emphasis> {\n"
"        // In this particular class the name of the new field was passed\n"
"        // from the name field of the ClassBridge Annotation. This is not\n"
"        // a requirement. It just works that way in this instance. The\n"
"        // actual name could be supplied by hard coding it below.\n"
"        Department dep = (Department) value;\n"
"        String fieldValue1 = dep.getBranch();\n"
"        if ( fieldValue1 == null ) {\n"
"            fieldValue1 = \"\";\n"
"        }\n"
"        String fieldValue2 = dep.getNetwork();\n"
"        if ( fieldValue2 == null ) {\n"
"            fieldValue2 = \"\";\n"
"        }\n"
"        String fieldValue = fieldValue1 + sepChar + fieldValue2;\n"
"        Field field = new Field( name, fieldValue, luceneOptions.getStore(), "
"luceneOptions.getIndex(), luceneOptions.getTermVector() );\n"
"        field.setBoost( luceneOptions.getBoost() );\n"
"        document.add( field );\n"
"   }\n"
"}"
msgstr ""

#. Tag: para
#: mapping.xml:979
#, no-c-format
msgid ""
"In this example, the particular <classname>CatFieldsClassBridge</classname> "
"is applied to the <literal>department</literal> instance, the field bridge "
"then concatenate both branch and network and index the concatenation."
msgstr ""

#. Tag: title
#: mapping.xml:989 mapping.xml:1014
#, no-c-format
msgid "Providing your own id"
msgstr ""

#. Tag: para
#: mapping.xml:992
#, no-c-format
msgid "This part of the documentation is a work in progress."
msgstr ""

#. Tag: para
#: mapping.xml:995
#, no-c-format
msgid ""
"You can provide your own id for Hibernate Search if you are extending the "
"internals. You will have to generate a unique value so it can be given to "
"Lucene to be indexed. This will have to be given to Hibernate Search when "
"you create an org.hibernate.search.Work object - the document id is required "
"in the constructor."
msgstr ""

#. Tag: title
#: mapping.xml:1002
#, no-c-format
msgid "The ProvidedId annotation"
msgstr ""

#. Tag: para
#: mapping.xml:1004
#, no-c-format
msgid ""
"Unlike conventional Hibernate Search API and @DocumentId, this annotation is "
"used on the class and not a field. You also can provide your own bridge "
"implementation when you put in this annotation by calling the bridge() which "
"is on @ProvidedId. Also, if you annotate a class with @ProvidedId, your "
"subclasses will also get the annotation - but it is not done by using the "
"java.lang.annotations.@Inherited. Be sure however, to <emphasis>not</"
"emphasis> use this annotation with @DocumentId as your system will break."
msgstr ""

#. Tag: programlisting
#: mapping.xml:1016
#, no-c-format
msgid ""
"@ProvidedId (bridge = org.my.own.package.MyCustomBridge)\n"
"@Indexed\n"
"public class MyClass{\n"
"    @Field\n"
"    String MyString;\n"
"    ...\n"
"}"
msgstr ""
