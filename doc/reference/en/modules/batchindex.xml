<?xml version="1.0" encoding="UTF-8"?>

<chapter id="search-batchindex">
  <!--  $Id$ -->	
  <title>Manual indexing</title>

  <section id="search-batchindex-indexing">
    <title>Indexing</title>

    <para>It is sometimes useful to index an object even if this object is not
    inserted nor updated to the database. This is especially true when you
    want to build your index for the first time. You can achieve that goal
    using the <classname>FullTextSession</classname>.</para>

    <programlisting>FullTextSession fullTextSession = Search.createFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <emphasis role="bold">fullTextSession.index(customer);</emphasis>
}
tx.commit(); //index are written at commit time    </programlisting>

    <para>For maximum efficiency, Hibernate Search batches index operations
    and executse them at commit time (Note: you don't need to use
    <classname>org.hibernate.Transaction</classname> in a JTA
    environment).</para>

    <para>If you expect to index a lot of data, you need to be careful about
    memory consumption: since all documents are kept in a queue until the
    transaction commit, you can potentially face an
    <classname>OutOfMemoryException</classname>.</para>

    <para>To avoid that, you can set up the
    <literal>hibernate.search.worker.batch_size</literal> property to a
    sensitive value: all index operations are queued until
    <literal>batch_size</literal> is reached. Every time
    <literal>batch_size</literal> is reached (or if the transaction is
    committed), the queue is processed (freeing memory) and emptied. Be aware
    that the changes cannot be rollbacked if the number of index elements goes
    beyond <literal>batch_size</literal>. Be also aware that the queue limits
    are also applied on regular transparent indexing (and not only when
    <literal>session.index()</literal> is used). That's why a sensitive
    <literal>batch_size</literal> value is expected.</para>

    <para>Other parameters which also can affect indexing time and memory
    consumption are
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_buffered_docs</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_field_length</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_merge_docs</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.merge_factor</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.ram_buffer_size</literal>
    and
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.term_index_interval</literal>
    . These parameters are Lucene specific and Hibernate Search is just
    passing these paramters through - see <xref
    linkend="lucene-indexing-performance" /> for more details.</para>

    <para>Here is an especially efficient way to index a given class (useful
    for index (re)initialization):</para>

    <programlisting>fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class ).scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % batchSize == 0) s.clear(); //clear every batchSize since the queue is processed
}
transaction.commit();</programlisting>

    <para>It is critical that <literal>batchSize</literal> in the previous
    example matches the <literal>batch_size</literal> value described
    previously.</para>
  </section>

  <section>
    <title>Purging</title>

    <para>It is equally possible to remove an entity or all entities of a
    given type from a Lucene index without the need to physically remove them
    from the database. This operation is named purging and is done through the
    <classname>FullTextSession</classname>.</para>

    <programlisting>FullTextSession fullTextSession = Search.createFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <emphasis role="bold">fullTextSession.purge( Customer.class, customer.getId() );</emphasis>
}
tx.commit(); //index are written at commit time    </programlisting>

    <para>Purging will remove the entity with the given id from the Lucene
    index but will not touch the database.</para>

    <para>If you need to remove all entities of a given type, you can use the
    <methodname>purgeAll</methodname> method.</para>

    <programlisting>FullTextSession fullTextSession = Search.createFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
<emphasis role="bold">fullTextSession.purgeAll( Customer.class );</emphasis>
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index are written at commit time    </programlisting>

    <para>It is recommended to optimize the index after such an
    operation.</para>

    <note>
      <para>Methods <methodname>index</methodname>,
      <methodname>purge</methodname> and <methodname>purgeAll</methodname> are
      available on <classname>FullTextEntityManager</classname> as well.</para>
    </note>
  </section>
</chapter>
