<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"> 
<chapter id="search-batchindex">
  <!--  $Id$ -->

  <title>Manual indexing</title>

  <section id="search-batchindex-indexing">
    <title>Indexing</title>

    <para>It is sometimes useful to index an object even if this object is not
    inserted nor updated to the database. This is especially true when you
    want to build your index for the first time. You can achieve that goal
    using the <classname>FullTextSession</classname>.</para>

    <programlisting>FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <emphasis role="bold">fullTextSession.index(customer);</emphasis>
}
tx.commit(); //index are written at commit time    </programlisting>

    <para>For maximum efficiency, Hibernate Search batches index operations
    and executes them at commit time (Note: you don't need to use
    <classname>org.hibernate.Transaction</classname> in a JTA
    environment).</para>

    <para>If you expect to index a lot of data, you need to be careful about
    memory consumption: since all documents are kept in a queue until the
    transaction commit, you can potentially face an
    <classname>OutOfMemoryException</classname>.</para>

    <para>To avoid that, you can use
    <methodname>fullTextSession.flushToIndexes()</methodname>: all index
    operations are queued until
    <methodname>fullTextSession.flushToIndexes()</methodname> is called. Every
    time <methodname>fullTextSession.flushToIndexes()</methodname> is called
    (or if the transaction is committed), the queue is processed (freeing
    memory) and emptied. Be aware that changes made before a flush cannot be
    rollbacked. </para>

    <note>
      <para><literal>hibernate.search.worker.batch_size</literal> has been
      deprecated in favor of this explicit API which provides better
      control</para>
    </note>

    <para>Other parameters which also can affect indexing time and memory
    consumption are
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_buffered_docs</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_field_length</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_merge_docs</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.merge_factor</literal>
    ,
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.ram_buffer_size</literal>
    and
    <literal>hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.term_index_interval</literal>
    . These parameters are Lucene specific and Hibernate Search is just
    passing these parameters through - see <xref
    linkend="lucene-indexing-performance" /> for more details.</para>

    <para>Here is an especially efficient way to index a given class (useful
    for index (re)initialization):</para>

    <programlisting>fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //clear since the queue is processed
    }
}
transaction.commit();</programlisting>

    <para>Try to use a batch size that guaranty that your application will not
    run out of memory.</para>
  </section>

  <section>
    <title>Purging</title>

    <para>It is equally possible to remove an entity or all entities of a
    given type from a Lucene index without the need to physically remove them
    from the database. This operation is named purging and is done through the
    <classname>FullTextSession</classname>.</para>

    <programlisting>FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <emphasis role="bold">fullTextSession.purge( Customer.class, customer.getId() );</emphasis>
}
tx.commit(); //index are written at commit time    </programlisting>

    <para>Purging will remove the entity with the given id from the Lucene
    index but will not touch the database.</para>

    <para>If you need to remove all entities of a given type, you can use the
    <methodname>purgeAll</methodname> method. This operation remove all entities of the type passed
        as a parameter as well as all its subtypes.</para>

    <programlisting>FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
<emphasis role="bold">fullTextSession.purgeAll( Customer.class );</emphasis>
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index are written at commit time    </programlisting>

    <para>It is recommended to optimize the index after such an
    operation.</para>

    <note>
      <para>Methods <methodname>index</methodname>,
      <methodname>purge</methodname> and <methodname>purgeAll</methodname> are
      available on <classname>FullTextEntityManager</classname> as
      well.</para>
    </note>
  </section>
</chapter>