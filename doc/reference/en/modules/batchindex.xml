<?xml version="1.0" encoding="UTF-8"?>
<!--  $Id$ -->
<chapter id="search-batchindex">

  <title>Indexing</title>

  <para>It is sometimes useful to index an object event if this object is not
  inserted nor updated to the database. This is especially true when you want
  to build your index the first time. You can achieve that goal using the
  <classname>FullTextSession</classname> .</para>

  <programlisting>FullTextSession fullTextSession = Search.createFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <emphasis role="bold">fullTextSession.index(customer);</emphasis>
}
tx.commit(); //index are written at commit time    </programlisting>

  <para>For maximum efficiency, Hibernate Search batch index operations which
  and execute them at commit time (Note: you don't need to use
  <classname>org.hibernate.Transaction</classname> in a JTA
  environment).</para>

  <para>If you expect to index a lot of data, you need to be careful about
  memory consumption: since all documents are kept in a queue until the
  transaction commit, you can potentially face an OutOfMemoryException.</para>

  <para>To avoid that, you can set up the
  <literal>hibernate.search.worker.batch_size</literal> property to a
  sensitive value: all index operations are queued until
  <literal>batch_size</literal> is reached. Every time
  <literal>batch_size</literal> is reached (or if the transaction is
  committed), the queue is processed (freeing memory) and emptied. Be aware
  that the changes cannot be rollbacked if the number of index elements goes
  beyond <literal>batch_size</literal>. Be also aware that the queue limits are
  also applied on regular transparent indexing (and not only when
  <literal>session.index()</literal> is used). That's why a sensitive
  <literal>batch_size</literal> value is expected.</para>

  <para>Other parameters which also can effect indexing time and memory consumption are 

  <literal>hibernate.search.[default|&lt;indexname&gt;].batch.merge_factor</literal>

  , 

  <literal>hibernate.search.[default|&lt;indexname&gt;].batch.max_merge_docs</literal>

   and 

  <literal>hibernate.search.[default|&lt;indexname&gt;].batch.max_buffered_docs</literal>

  . These parameters are Lucene specific and Hibernate Search is just passing these paramters through - see 

  <xref linkend="lucene-indexing-performance" />

   for more details. 
</para>
  <para>Here is an especially efficient way to index a given class (useful for
  index (re)initialization):</para>

   

  <programlisting>fullTextSession.setFlushMode(FlushMode.MANUAL);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class ).scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % batchSize == 0) s.clear(); //clear every batchSize since the queue is processed
}
transaction.commit();</programlisting>

   

  <para>It is critical that <literal>batchSize</literal> in the previous
  example matches the <literal>batch_size</literal> value described
  previously.</para>

   
</chapter>